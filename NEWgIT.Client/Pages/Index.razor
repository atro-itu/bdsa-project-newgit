@page "/"
@using Radzen;
@using System.Globalization;
@using System;
@using System.Linq;
@using System.Collections.Generic;
@using System.Net.Http;
@using System.Text.Json;
@using System.Text.Json.Serialization;

@inject HttpClient Http



<RadzenText TextStyle="TextStyle.H2" TagName="TagName.H1" Class="my-4" TextAlign="TextAlign.Center">
    Welcome to NEWgIT
</RadzenText>

<RadzenAlert AlertStyle="AlertStyle.Danger" ShowIcon="true" Variant="Variant.Flat" Shade="Shade.Lighter" Visible="@NotFoundAlert">
    Repository Not Found
</RadzenAlert>

<RadzenText TextStyle="TextStyle.Subtitle2" TagName="TagName.H3" TextAlign="TextAlign.Center"></RadzenText>
<div style="display: flex; flex-direction: row; width: 500px; margin: auto;">
    <RadzenTextBox Placeholder="Repository owner" Change=@(args => OnChangeRepoOwner(args)) Class="TextBox" style="margin: 0px 12px"/>
    <h2>/</h2>
    <RadzenTextBox Placeholder="Repository name" Change=@(args => OnChangeRepoName(args)) Class="TextBox" style="margin: 0px 12px"/>
</div>

<AuthorizeView>
    <Authorized>
        <RadzenButton class="AnalyzeButton" Click=@(args => OnAnalysis("Primary button")) Text="Analyze" ButtonStyle="ButtonStyle.Primary"/>
    </Authorized>
    <NotAuthorized>
        You need to log in.
    </NotAuthorized>
</AuthorizeView>

@if (repoOwner != null && repoName != null)
{
    <RadzenText TextStyle="TextStyle.H4" TagName="TagName.H1" Class="my-4" TextAlign="TextAlign.Center">
        Commit Frequency
    </RadzenText>

    <RadzenChart>
        <RadzenColumnSeries Data="@allCommits" CategoryProperty="Date" Title="All Commits" LineType="LineType.Dashed" ValueProperty="commits">
        </RadzenColumnSeries>
        <RadzenColumnOptions Radius="5"/>
        <RadzenValueAxis>
            <RadzenGridLines Visible="true"/>
        </RadzenValueAxis>
    </RadzenChart>

    <RadzenAlert AlertStyle="AlertStyle.Danger" ShowIcon="true" Variant="Variant.Flat" Shade="Shade.Lighter" Visible="@NotFoundAlertAuthors">
        Authors Not Found
    </RadzenAlert>

    <RadzenText TextStyle="TextStyle.H4" TagName="TagName.H1" Class="my-4" TextAlign="TextAlign.Center">
        Commit Frequency pr author
    </RadzenText>

@foreach (var author in commitsPrAuthor)
{
    <RadzenChart>
        <RadzenColumnSeries Data="@author.Value" CategoryProperty="Date" Title="@author.Key" LineType="LineType.Dashed" ValueProperty="commits">
        </RadzenColumnSeries>
        <RadzenColumnOptions Radius="5"/>
        <RadzenValueAxis>
            <RadzenGridLines Visible="true"/>
        </RadzenValueAxis>
    </RadzenChart>
}

    <RadzenText TextStyle="TextStyle.H4" TagName="TagName.H1" Class="my-4" TextAlign="TextAlign.Center">
        Forks
    </RadzenText>
    <div class="forks-list">
        <RadzenDataList WrapItems="true" AllowPaging="false" Data="@ShownForks" TItem="string" EmptyText="This repository hasn't been forked">
            <Template Context="fork">
                <a href="https://github.com/@fork" class="github-card">
                    <img src="https://gh-card.dev/repos/@fork .svg?fullname="/>
                </a>
            </Template>
        </RadzenDataList>
        <RadzenPager ShowPagingSummary="true" PagingSummaryFormat="@pagingSummaryFormat" HorizontalAlign="HorizontalAlign.Right" Count="count" PageSize="@pageSize" PageNumbersCount="5" PageChanged="@PageChanged" />
    </div>
}

@code {
    ICollection<string> Forks = new List<string>();
    Dictionary<DateOnly, int> frequencyDictionary;
    Dictionary<string, Dictionary<DateOnly, int>> authorDictionary;
    Dictionary<string, commitItem[]> commitsPrAuthor = new Dictionary<string, commitItem[]>();
    string[] commitsPrAuthors;
    string repoOwner;
    string repoName;
    commitItem[] allCommits;
    bool NotFoundAlert = false;
    bool NotFoundAlertAuthors = false;
    Random rand = new Random();
    string pagingSummaryFormat = "Displaying page {0} of {1} (total {2} records)";
    int pageSize = 6;
    int count;
    IEnumerable<string> ShownForks;

    void OnChangeRepoOwner(string repoOwner)
    {
        this.repoOwner = repoOwner;
    }

    void OnChangeRepoName(string repoName)
    {
        this.repoName = repoName;
    }

    async void OnAnalysis(string buttonName)
    {
        NotFoundAlert = false;
        NotFoundAlertAuthors = false;
        StateHasChanged();

        // TODO: Reset 
        
        analyse();
        analyseAllCommits();
        analysePrAuthor();
        analyseForks();
    }

    async void analyse()
    {
        try
        {
            HttpResponseMessage responsePost = await Http.PostAsync($"https://localhost:7235/analysis/{repoOwner}/{repoName}", null);
            if ((int)responsePost.StatusCode == 409){
                HttpResponseMessage responsePut = await Http.PutAsync($"https://localhost:7235/analysis/{repoOwner}/{repoName}", null);
            } 
            if ((int)responsePost.StatusCode == 404){
                NotFoundAlert = true;
                StateHasChanged();
                return;
            }
        }
        catch (HttpRequestException e)
        {
            Console.WriteLine("\nException Caught!");
            Console.WriteLine("Message :{0} ", e.Message);
        }
    }

    async void analyseAllCommits()
    {
        try
        {   
            HttpResponseMessage responseGet = await Http.GetAsync($"https://localhost:7235/analysis/{repoOwner}/{repoName}/frequency");
            if ((int)responseGet.StatusCode == 404){
                NotFoundAlert = true;
                StateHasChanged();
                return;
            }
            responseGet.EnsureSuccessStatusCode();

            var responseBody = await responseGet.Content.ReadFromJsonAsync<FrequenciesDTO>();
            var frequencyDictionary = responseBody.Frequencies;
            allCommits = new commitItem[frequencyDictionary.Count];
            convert(frequencyDictionary, allCommits);
        }
        catch (HttpRequestException e)
        {
            Console.WriteLine("\nException Caught!");
            Console.WriteLine("Message :{0} ", e.Message);
        }
    }

    async void analysePrAuthor()
    {
        try
        {
            HttpResponseMessage responsePrAuthor = await Http.GetAsync($"https://localhost:7235/analysis/{repoOwner}/{repoName}/author");
            if ((int)responsePrAuthor.StatusCode == 404){
                NotFoundAlertAuthors = true;
                StateHasChanged();
                return;
            }
            
            responsePrAuthor.EnsureSuccessStatusCode();

            var responseBody = await responsePrAuthor.Content.ReadFromJsonAsync<AuthorsDTO>();
            var authorDictionary = responseBody.AuthorFrequencies;
            commitsPrAuthor.Clear();
            foreach (var author in authorDictionary)
            {
                commitItem[] authorArr = new commitItem[author.Value.Count];
                convert(author.Value, authorArr);
                commitsPrAuthor.Add(author.Key, authorArr);
            }
        }
        catch (HttpRequestException e)
        {
            Console.WriteLine("\nException Caught!");
            Console.WriteLine("Message :{0} ", e.Message);
        }
    }

    async void analyseForks()
    {
        try
        {
            HttpResponseMessage response = await Http.GetAsync($"https://localhost:7235/analysis/{repoOwner}/{repoName}/forks");
            response.EnsureSuccessStatusCode();
            var responseBody = await response.Content.ReadFromJsonAsync<ForksDTO>();
            Forks = responseBody.Forks;
            await ForksLoadedAsync();
            StateHasChanged();
        }
        catch (HttpRequestException e)
        {
            Console.WriteLine("\nException Caught!");
            Console.WriteLine("Message :{0} ", e.Message);
        }
    }

    void convert(Dictionary<DateOnly, int> toBeConverted, commitItem[] arr)
    {
        var sortedDictionary = new SortedDictionary<DateOnly, int>(toBeConverted);
        int counter = 0;
        
        foreach (var date in sortedDictionary)
        {
            arr[counter] = new commitItem
            {
                Date = date.Key,
                Commits = date.Value
            };
            counter++;
        }
        StateHasChanged();
    }

    protected async Task ForksLoadedAsync()
    {
        count = Forks.Count();
        ShownForks = GetForks(0, pageSize);
    }

    void PageChanged(PagerEventArgs args)
    {
        ShownForks = GetForks(args.Skip, args.Top);
    }

    IEnumerable<string> GetForks(int skip, int take)
    {
        return Forks.Skip(skip).Take(take).ToList();
    }

    //Helper 
    class commitItem
    {
        public DateOnly Date { get; set; }
        public int Commits { get; set; }
    }

    public record AuthorsDTO(Dictionary<string, Dictionary<DateOnly, int>> AuthorFrequencies);
    
    public record ForksDTO(ICollection<string> Forks);

    public record FrequenciesDTO(Dictionary<DateOnly, int> Frequencies);
}
